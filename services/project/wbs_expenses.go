// Copyright 2022 The go-exactonline AUTHORS. All rights reserved.
//
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
// Code generated by gen-services.go; DO NOT EDIT.
package project

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/stack11/go-exactonline/api"
	"github.com/stack11/go-exactonline/types"
)

// WBSExpensesEndpoint is responsible for communicating with
// the WBSExpenses endpoint of the Project service.
type WBSExpensesEndpoint service

// WBSExpenses:
// Service: Project
// Entity: WBSExpenses
// URL: /api/v1/{division}/project/WBSExpenses
// HasWebhook: false
// IsInBeta: false
// Methods: GET POST PUT DELETE
// Endpoint docs: https://start.exactonline.nl/docs/HlpRestAPIResourcesDetails.aspx?name=ProjectWBSExpenses
type WBSExpenses struct {
	MetaData *api.MetaData `json:"__metadata,omitempty"`
	// ID: Primary key
	ID *types.GUID `json:"ID,omitempty"`

	// AutoCreateInvoiceTerm: To indicated auto create invoice term when invoice method is Fixed
	AutoCreateInvoiceTerm *bool `json:"AutoCreateInvoiceTerm,omitempty"`

	// BlockEntry: To indicated if cost entries is blocked
	BlockEntry *bool `json:"BlockEntry,omitempty"`

	// BlockRebilling: To indicated if rebilling is blocked
	BlockRebilling *bool `json:"BlockRebilling,omitempty"`

	// BudgetedCost: Budget cost of the WBS expense
	BudgetedCost *float64 `json:"BudgetedCost,omitempty"`

	// BudgetedRevenue: Revenue of the WBS expense
	BudgetedRevenue *float64 `json:"BudgetedRevenue,omitempty"`

	// Completed: To indicated if the WBS expense is completed
	Completed *bool `json:"Completed,omitempty"`

	// Created: The date and time when the WBS expense was created
	Created *types.Date `json:"Created,omitempty"`

	// Creator: The ID of the user that created the WBS expense
	Creator *types.GUID `json:"Creator,omitempty"`

	// CreatorFullName: The full name of the user that created the WBS expense
	CreatorFullName *string `json:"CreatorFullName,omitempty"`

	// CustomField: Custom field endpoint. Provided only for the Exact Online Premium users.
	CustomField *string `json:"CustomField,omitempty"`

	// Description: Description of the WBS expense
	Description *string `json:"Description,omitempty"`

	// Division: Division code
	Division *int `json:"Division,omitempty"`

	// EndDate: End date of the WBS expense
	EndDate *types.Date `json:"EndDate,omitempty"`

	// InvoiceDate: The invoice term date of the WBS when set to fixed billing
	InvoiceDate *types.Date `json:"InvoiceDate,omitempty"`

	// InvoiceMethod: The invoice method of the WBS. E.g: 6 = Fixed, 7 = Rebill, 8 = Non re-billable
	InvoiceMethod *int `json:"InvoiceMethod,omitempty"`

	// InvoiceSeparately: To indicated if additional invoice is allowed on this WBS expense. Additional invoice can only be set when the project type is fixed price or prepaid and the project allow additional invoices. (Obsolete)
	InvoiceSeparately *bool `json:"InvoiceSeparately,omitempty"`

	// InvoiceTerm: ID of the invoice term that linked to the WBS
	InvoiceTerm *types.GUID `json:"InvoiceTerm,omitempty"`

	// Item: Item to used for cost entry
	Item *types.GUID `json:"Item,omitempty"`

	// MarkupPercentage: Markup percentage
	MarkupPercentage *float64 `json:"MarkupPercentage,omitempty"`

	// Modified: The date when the WBS expense was modified
	Modified *types.Date `json:"Modified,omitempty"`

	// Modifier: The ID of the user that modified the WBS expense
	Modifier *types.GUID `json:"Modifier,omitempty"`

	// ModifierFullName: The full name of the user that modified the WBS expense
	ModifierFullName *string `json:"ModifierFullName,omitempty"`

	// Notes: For additional information
	Notes *string `json:"Notes,omitempty"`

	// PartOf: ID of the WBS expense part of
	PartOf *types.GUID `json:"PartOf,omitempty"`

	// PartOfDescription: Description of part of
	PartOfDescription *string `json:"PartOfDescription,omitempty"`

	// Project: ID of the project that linked to WBS expense
	Project *types.GUID `json:"Project,omitempty"`

	// ProjectDescription: Project description that is linked to WBS expense
	ProjectDescription *string `json:"ProjectDescription,omitempty"`

	// ProjectTermAction: Project term action
	ProjectTermAction *int `json:"ProjectTermAction,omitempty"`

	// PurchasePrice: Purchase price of the item
	PurchasePrice *float64 `json:"PurchasePrice,omitempty"`

	// Quantity: Quantity of the WBS
	Quantity *float64 `json:"Quantity,omitempty"`

	// ReleaseInvoiceTerm: Action to release the invoice term. You can only release a WBS expense&#39;s invoice term once and it cannot be undo
	ReleaseInvoiceTerm *bool `json:"ReleaseInvoiceTerm,omitempty"`

	// ReleaseInvoiceTermDate: Release invoice term date. The linked invoice term date can be updated by using this property. The update will only happen when releasing a WBS expense&#39;s invoice term
	ReleaseInvoiceTermDate *types.Date `json:"ReleaseInvoiceTermDate,omitempty"`

	// ReleaseInvoiceTermHasSpecifyDate: Release invoice term has specify date
	ReleaseInvoiceTermHasSpecifyDate *bool `json:"ReleaseInvoiceTermHasSpecifyDate,omitempty"`

	// SequenceNumber: Sequence number of the WBS deliverable. Last sequence will be selected if not specified
	SequenceNumber *int `json:"SequenceNumber,omitempty"`

	// StartDate: Start date of the WBS expense
	StartDate *types.Date `json:"StartDate,omitempty"`

	// Supplier: Supplier of the item
	Supplier *types.GUID `json:"Supplier,omitempty"`

	// Type: The type of project WBS. E.g: 1 = Deliverable, 2 = Activity, 3 = Expense
	Type *int `json:"Type,omitempty"`

	// UpdateAction: Update action
	UpdateAction *int `json:"UpdateAction,omitempty"`
}

func (e *WBSExpenses) GetPrimary() *types.GUID {
	return e.ID
}

func (s *WBSExpensesEndpoint) UserHasRights(ctx context.Context, division int, method string) (bool, error) {
	return s.client.UserHasRights(ctx, division, "project/WBSExpenses", method)
}

// List the WBSExpenses entities in the provided division.
// If all is true, all the paginated results are fetched; if false, list the first page.
func (s *WBSExpensesEndpoint) List(ctx context.Context, division int, all bool, o *api.ListOptions) ([]*WBSExpenses, error) {
	var entities []*WBSExpenses
	u, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/project/WBSExpenses", division) // #nosec
	api.AddListOptionsToURL(u, o)

	if all {
		err := s.client.ListRequestAndDoAll(ctx, u.String(), &entities)
		return entities, err
	}
	_, _, err := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, &entities)
	return entities, err
}

// Get the WBSExpenses entitiy in the provided division.
func (s *WBSExpensesEndpoint) Get(ctx context.Context, division int, id *types.GUID) (*WBSExpenses, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/project/WBSExpenses", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return nil, err
	}

	e := &WBSExpenses{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, e)
	return e, requestError
}

// New returns an empty WBSExpenses entity
func (s *WBSExpensesEndpoint) New() *WBSExpenses {
	return &WBSExpenses{}
}

// Create the WBSExpenses entity in the provided division.
func (s *WBSExpensesEndpoint) Create(ctx context.Context, division int, entity *WBSExpenses) (*WBSExpenses, error) {
	u, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/project/WBSExpenses", division) // #nosec
	e := &WBSExpenses{}
	_, _, err := s.client.NewRequestAndDo(ctx, "POST", u.String(), entity, e)
	if err != nil {
		return nil, err
	}
	return e, nil
}

// Update the WBSExpenses entity in the provided division.
func (s *WBSExpensesEndpoint) Update(ctx context.Context, division int, entity *WBSExpenses) (*WBSExpenses, error) {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/project/WBSExpenses", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, entity.GetPrimary())
	if err != nil {
		return nil, err
	}

	e := &WBSExpenses{}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "PUT", u.String(), entity, e)
	return e, requestError
}

// Delete the WBSExpenses entity in the provided division.
func (s *WBSExpensesEndpoint) Delete(ctx context.Context, division int, id *types.GUID) error {
	b, _ := s.client.ResolvePathWithDivision("/api/v1/{division}/project/WBSExpenses", division) // #nosec
	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return err
	}

	_, r, requestError := s.client.NewRequestAndDo(ctx, "DELETE", u.String(), nil, nil)
	if requestError != nil {
		return requestError
	}

	if r.StatusCode != http.StatusNoContent {
		body, _ := ioutil.ReadAll(r.Body) // #nosec
		return fmt.Errorf("Failed with status %v and body %v", r.StatusCode, body)
	}

	return nil
}
